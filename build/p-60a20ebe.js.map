{"version":3,"sources":["../node_modules/tabbable/dist/index.esm.js","../node_modules/focus-trap/dist/focus-trap.esm.js","src/utils/first-tabbable.ts"],"names":["candidateSelectors","candidateSelector","join","NoElement","Element","matches","prototype","msMatchesSelector","webkitMatchesSelector","getRootNode","element","ownerDocument","getCandidates","el","includeContainer","filter","candidates","Array","slice","apply","querySelectorAll","call","unshift","getCandidatesIteratively","elements","options","elementsToCheck","from","length","shift","tagName","assigned","assignedElements","content","children","nestedCandidates","flatten","push","scope","validCandidate","includes","shadowRoot","getShadowRoot","validShadowRoot","shadowRootFilter","_nestedCandidates","getTabindex","node","isScope","tabIndex","test","isContentEditable","isNaN","parseInt","getAttribute","sortOrderedTabbables","a","b","documentOrder","isInput","isHiddenInput","type","isDetailsWithSummary","r","some","child","getCheckedRadio","nodes","form","i","checked","isTabbableRadio","name","radioScope","queryRadios","radioSet","window","CSS","escape","err","console","error","message","isRadio","isNonTabbableRadio","isNodeAttached","_nodeRootHost","nodeRootHost","host","attached","contains","_nodeRootHost2","isZeroArea","_node$getBoundingClie","getBoundingClientRect","width","height","isHidden","_ref","displayCheck","getComputedStyle","visibility","isDirectSummary","nodeUnderDetails","parentElement","originalNode","rootNode","assignedSlot","getClientRects","isDisabledFromFieldset","parentNode","disabled","item","isNodeMatchingSelectorFocusable","isNodeMatchingSelectorTabbable","isValidShadowRootTabbable","shadowHostNode","sortByOrder","regularTabbables","orderedTabbables","forEach","candidateTabindex","sort","reduce","acc","sortable","concat","tabbable","bind","focusable","isTabbable","Error","focusableCandidateSelector","isFocusable","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","enumerable","_objectSpread2","target","arguments","source","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","activeFocusTraps","trapQueue","activateTrap","trap","activeTrap","pause","trapIndex","indexOf","splice","deactivateTrap","unpause","isSelectableInput","toLowerCase","select","isEscapeEvent","e","keyCode","isTabEvent","delay","fn","setTimeout","findIndex","arr","idx","every","valueOrHandler","_len","params","_key","getActualTarget","event","composedPath","createFocusTrap","userOptions","doc","document","config","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","undefined","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","container","tabbableNodes","find","getNodeForOption","optionValue","_len2","_key2","querySelector","getInitialFocusNode","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","map","tabbableOptions","focusableNodes","lastTabbableNode","nextTabbableNode","forward","nodeIdx","n","reverse","group","tryFocus","focus","preventScroll","getReturnFocusNode","previousActiveElement","checkPointerDown","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","preventDefault","checkFocusIn","targetContained","Document","stopImmediatePropagation","checkTab","destinationNode","containerIndex","containerGroup","shiftKey","startOfGroupIndex","_ref2","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref3","_destinationGroupIndex","_destinationGroup","checkKey","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","activate","activateOptions","this","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","clearTimeout","finishDeactivation","updateContainerElements","containerElements","elementsAsArray","Boolean","firstTabbable"],"mappings":"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","sourcesContent":["/*!\n* tabbable 6.0.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\n\n\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      } // iterate over shadow content if possible\n\n\n      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n\n  return candidates;\n};\n\nvar getTabindex = function getTabindex(node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || getRootNode(node);\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}; // determines if a node is ultimately attached to the window's document\n\n\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRootHost;\n\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  var nodeRootHost = getRootNode(node).host;\n  var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));\n\n  while (!attached && nodeRootHost) {\n    var _nodeRootHost2;\n\n    // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n    //  which means we need to get the host's host and check if that parent host is contained\n    //  in (i.e. attached to) the document\n    nodeRootHost = getRootNode(nodeRootHost).host;\n    attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));\n  }\n\n  return attached;\n};\n\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height;\n\n  return width === 0 && height === 0;\n};\n\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n      getShadowRoot = _ref.getShadowRoot;\n\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    } // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n\n\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    } // else, fallback to 'none' mode and consider the node visible\n\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  } // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i); // when the first <legend> (in document order) is found\n\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        } // the disabled <fieldset> containing `node` has no <legend>\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  } // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n\n\n  return false;\n};\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\n\n\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scope;\n    var element = isScope ? item.scope : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n\n  return sortByOrder(candidates);\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 7.0.0\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, focusable, isTabbable, isFocusable } from 'tabbable';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\n\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n}; // Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\n\n\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n  return idx;\n};\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\n\n\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\n\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n\n\n  var findContainerIndex = function findContainerIndex(element) {\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n          tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n\n\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n\n      optionValue = optionValue.apply(void 0, params);\n    }\n\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      } // else, empty string (invalid), null (invalid), 0 (invalid)\n\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n\n    return node;\n  };\n\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus'); // false explicitly indicates we want no initialFocus at all\n\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  };\n\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions); // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes\n\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,\n\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n          //  from the DOM order), this __will not work__ because the list of focusableNodes,\n          //  while it contains tabbable nodes, does not sort its nodes in any order other\n          //  than DOM order, because it can't: Where would you place focusable (but not\n          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n          // Support for positive tabindex is already broken and hard to manage (possibly\n          //  not supportable, TBD), so this isn't going to make things worse than they\n          //  already are, and at least makes things better for the majority of cases where\n          //  tabindex is either 0/unset or negative.\n          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n          var nodeIdx = focusableNodes.findIndex(function (n) {\n            return n === node;\n          });\n\n          if (nodeIdx < 0) {\n            return undefined;\n          }\n\n          if (forward) {\n            return focusableNodes.slice(nodeIdx + 1).find(function (n) {\n              return isTabbable(n, config.tabbableOptions);\n            });\n          }\n\n          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {\n            return isTabbable(n, config.tabbableOptions);\n          });\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    }); // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  }; // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  }; // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = findContainerIndex(target) >= 0; // In Firefox when you Tab out of an iframe the Document is briefly focused.\n\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  }; // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  var checkTab = function checkTab(e) {\n    var target = getActualTarget(e);\n    updateTabbableNodes();\n    var destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    } // else, let the browser take care of [shift+]tab and move the focus\n\n  };\n\n  var checkKey = function checkKey(e) {\n    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }; //\n  // EVENT LISTENERS\n  //\n\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    } // There can be only one listening focus trap at a time\n\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }; //\n  // TRAP DEFINITION\n  //\n\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n\n    get paused() {\n      return state.paused;\n    },\n\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n\n        addListeners();\n\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    }\n  }; // initialize container elements\n\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","import { FocusableElement, tabbable } from 'tabbable';\n\ntype Container = Element | FocusableElement | null;\n\nconst firstTabbable = (container?: Container): FocusableElement | undefined => {\n  return (container ? tabbable(container, { includeContainer: true, getShadowRoot: true }) : []).shift();\n};\n\nexport default firstTabbable;\n"]}